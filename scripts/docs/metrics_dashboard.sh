#!/bin/bash

# =============================================================================
# SISTEMA LANCEI ESSA - DASHBOARD DE M√âTRICAS DA DOCUMENTA√á√ÉO
# =============================================================================
# Descri√ß√£o: Sistema automatizado de m√©tricas e dashboard para documenta√ß√£o
# Autor: Sistema Automatizado de Documenta√ß√£o
# Data: $(date '+%d/%m/%Y')
# Vers√£o: 1.0
# =============================================================================

set -euo pipefail

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Configura√ß√µes
DOCS_DIR="docs"
METRICS_DIR="$DOCS_DIR/metrics"
DASHBOARD_FILE="$METRICS_DIR/quality-dashboard.md"
METRICS_JSON="$DOCS_DIR/project-management/docs-metrics.json"
HISTORY_FILE="$METRICS_DIR/metrics-history.json"

# Vari√°veis de m√©tricas
TOTAL_FILES=0
TOTAL_LINES=0
TOTAL_SIZE=0
BROKEN_LINKS=0
MISSING_FILES=0
FORMAT_ISSUES=0
COVERAGE_SCORE=0
QUALITY_SCORE=0

echo -e "${BLUE}üìä SISTEMA LANCEI ESSA - DASHBOARD DE M√âTRICAS${NC}"
echo "================================================================="
echo -e "üìÖ Executado em: ${YELLOW}$(date)${NC}"
echo -e "üìÇ Diret√≥rio: ${YELLOW}$(pwd)${NC}"
echo ""

# Fun√ß√£o para criar diret√≥rios necess√°rios
setup_directories() {
    mkdir -p "$METRICS_DIR"
    echo -e "${GREEN}‚úÖ Diret√≥rio de m√©tricas configurado${NC}"
}

# Fun√ß√£o para coletar m√©tricas b√°sicas
collect_basic_metrics() {
    echo -e "${BLUE}üìã Coletando m√©tricas b√°sicas...${NC}"
    
    # Contar arquivos markdown
    TOTAL_FILES=$(find "$DOCS_DIR" -name "*.md" -not -path "*/archived/*" | wc -l)
    
    # Contar linhas de documenta√ß√£o
    TOTAL_LINES=$(find "$DOCS_DIR" -name "*.md" -not -path "*/archived/*" -exec wc -l {} + | tail -1 | awk '{print $1}')
    
    # Calcular tamanho total
    TOTAL_SIZE=$(du -sh "$DOCS_DIR" | cut -f1)
    
    echo -e "${CYAN}   üìÑ Arquivos markdown: ${YELLOW}$TOTAL_FILES${NC}"
    echo -e "${CYAN}   üìù Total de linhas: ${YELLOW}$TOTAL_LINES${NC}"
    echo -e "${CYAN}   üíæ Tamanho total: ${YELLOW}$TOTAL_SIZE${NC}"
}

# Fun√ß√£o para analisar cobertura da documenta√ß√£o
analyze_coverage() {
    echo -e "${BLUE}üîç Analisando cobertura da documenta√ß√£o...${NC}"
    
    local required_docs=(
        "README.md"
        "user-guide/getting-started.md"
        "user-guide/faq.md"
        "developer-guide/quick-start.md"
        "developer-guide/architecture/overview.md"
        "operations/deployment/production-setup.md"
        "project-management/status.md"
        "templates/style-guide.md"
    )
    
    local existing_docs=0
    local total_required=${#required_docs[@]}
    
    for doc in "${required_docs[@]}"; do
        if [[ -f "$DOCS_DIR/$doc" ]]; then
            ((existing_docs++))
        fi
    done
    
    COVERAGE_SCORE=$((existing_docs * 100 / total_required))
    
    echo -e "${CYAN}   üìä Documentos obrigat√≥rios: ${existing_docs}/${total_required}${NC}"
    echo -e "${CYAN}   üéØ Score de cobertura: ${YELLOW}$COVERAGE_SCORE%${NC}"
}

# Fun√ß√£o para verificar qualidade do conte√∫do
analyze_content_quality() {
    echo -e "${BLUE}üìù Analisando qualidade do conte√∫do...${NC}"
    
    local quality_issues=0
    local total_checks=0
    
    # Verificar arquivos sem headers
    local files_without_headers=$(find "$DOCS_DIR" -name "*.md" -not -path "*/archived/*" -exec grep -L "^# " {} \; | wc -l)
    ((total_checks++))
    if [[ $files_without_headers -gt 0 ]]; then
        ((quality_issues++))
    fi
    
    # Verificar arquivos muito curtos (< 10 linhas)
    local short_files=$(find "$DOCS_DIR" -name "*.md" -not -path "*/archived/*" -exec wc -l {} \; | awk '$1 < 10 {print $2}' | wc -l)
    ((total_checks++))
    if [[ $short_files -gt 2 ]]; then  # Tolerar at√© 2 arquivos curtos
        ((quality_issues++))
    fi
    
    # Verificar README principal
    ((total_checks++))
    if [[ -f "README.md" ]] && [[ $(wc -l < "README.md") -gt 50 ]]; then
        # README tem tamanho adequado
        :
    else
        ((quality_issues++))
    fi
    
    # Verificar se h√° TOC nos documentos longos
    local long_docs_without_toc=$(find "$DOCS_DIR" -name "*.md" -not -path "*/archived/*" -exec sh -c 'wc -l < "$1" | awk "(\$1 > 100)" && ! grep -q "## " "$1" && echo "$1"' _ {} \; | wc -l)
    ((total_checks++))
    if [[ $long_docs_without_toc -gt 0 ]]; then
        ((quality_issues++))
    fi
    
    # Calcular score de qualidade do conte√∫do
    local content_quality_score=$((100 - (quality_issues * 100 / total_checks)))
    
    echo -e "${CYAN}   üìä Verifica√ß√µes de qualidade: $((total_checks - quality_issues))/${total_checks}${NC}"
    echo -e "${CYAN}   üéØ Score de qualidade: ${YELLOW}$content_quality_score%${NC}"
    
    # Atualizar contadores globais
    FORMAT_ISSUES=$quality_issues
}

# Fun√ß√£o para analisar estrutura e navega√ß√£o
analyze_navigation() {
    echo -e "${BLUE}üó∫Ô∏è Analisando navega√ß√£o e estrutura...${NC}"
    
    local nav_score=100
    
    # Verificar se README principal tem navega√ß√£o
    if [[ -f "$DOCS_DIR/README.md" ]]; then
        if ! grep -qE "\[.*\]\(.*\.md\)" "$DOCS_DIR/README.md"; then
            nav_score=$((nav_score - 20))
        fi
    else
        nav_score=$((nav_score - 30))
    fi
    
    # Verificar estrutura de diret√≥rios
    local required_dirs=("user-guide" "developer-guide" "operations" "templates")
    local missing_dirs=0
    
    for dir in "${required_dirs[@]}"; do
        if [[ ! -d "$DOCS_DIR/$dir" ]]; then
            ((missing_dirs++))
        fi
    done
    
    nav_score=$((nav_score - (missing_dirs * 15)))
    
    # Limitar score m√≠nimo
    if [[ $nav_score -lt 0 ]]; then
        nav_score=0
    fi
    
    echo -e "${CYAN}   üóÇÔ∏è Diret√≥rios estruturais: $((${#required_dirs[@]} - missing_dirs))/${#required_dirs[@]}${NC}"
    echo -e "${CYAN}   üß≠ Score de navega√ß√£o: ${YELLOW}$nav_score%${NC}"
    
    return $nav_score
}

# Fun√ß√£o para carregar m√©tricas de valida√ß√£o
load_validation_metrics() {
    echo -e "${BLUE}üìä Carregando m√©tricas de valida√ß√£o...${NC}"
    
    if [[ -f "$METRICS_JSON" ]]; then
        BROKEN_LINKS=$(jq -r '.validation.brokenLinks // 0' "$METRICS_JSON")
        MISSING_FILES=$(jq -r '.validation.missingFiles // 0' "$METRICS_JSON")
        QUALITY_SCORE=$(jq -r '.validation.qualityScore // 85' "$METRICS_JSON")
        
        echo -e "${CYAN}   üîó Links quebrados: ${YELLOW}$BROKEN_LINKS${NC}"
        echo -e "${CYAN}   üìÑ Arquivos ausentes: ${YELLOW}$MISSING_FILES${NC}"
        echo -e "${CYAN}   üéØ Score valida√ß√£o: ${YELLOW}$QUALITY_SCORE%${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  M√©tricas de valida√ß√£o n√£o encontradas. Execute validate_docs.sh primeiro${NC}"
        QUALITY_SCORE=85  # Score padr√£o conservador
    fi
}

# Fun√ß√£o para calcular score geral
calculate_overall_score() {
    echo -e "${BLUE}üéØ Calculando score geral de qualidade...${NC}"
    
    # Pesos para diferentes aspectos
    local coverage_weight=25
    local quality_weight=30
    local navigation_weight=20
    local validation_weight=25
    
    # Obter score de navega√ß√£o
    analyze_navigation
    local nav_score=$?
    
    # Calcular score ponderado
    QUALITY_SCORE=$(( 
        (COVERAGE_SCORE * coverage_weight + 
         (100 - FORMAT_ISSUES * 10) * quality_weight + 
         nav_score * navigation_weight + 
         QUALITY_SCORE * validation_weight) / 100
    ))
    
    # Limitar entre 0 e 100
    if [[ $QUALITY_SCORE -gt 100 ]]; then
        QUALITY_SCORE=100
    elif [[ $QUALITY_SCORE -lt 0 ]]; then
        QUALITY_SCORE=0
    fi
    
    echo -e "${CYAN}   üèÜ Score geral: ${YELLOW}$QUALITY_SCORE%${NC}"
}

# Fun√ß√£o para salvar hist√≥rico de m√©tricas
save_metrics_history() {
    echo -e "${BLUE}üíæ Salvando hist√≥rico de m√©tricas...${NC}"
    
    local timestamp=$(date -Iseconds)
    local new_entry=$(cat << EOF
{
  "timestamp": "$timestamp",
  "date": "$(date '+%Y-%m-%d')",
  "time": "$(date '+%H:%M:%S')",
  "metrics": {
    "totalFiles": $TOTAL_FILES,
    "totalLines": $TOTAL_LINES,
    "totalSize": "$TOTAL_SIZE",
    "coverageScore": $COVERAGE_SCORE,
    "qualityScore": $QUALITY_SCORE,
    "brokenLinks": $BROKEN_LINKS,
    "missingFiles": $MISSING_FILES,
    "formatIssues": $FORMAT_ISSUES
  }
}
EOF
)
    
    # Criar ou atualizar hist√≥rico
    if [[ -f "$HISTORY_FILE" ]]; then
        # Adicionar nova entrada ao array existente
        local temp_file=$(mktemp)
        jq ". += [$new_entry]" "$HISTORY_FILE" > "$temp_file"
        mv "$temp_file" "$HISTORY_FILE"
    else
        # Criar novo arquivo de hist√≥rico
        echo "[$new_entry]" > "$HISTORY_FILE"
    fi
    
    echo -e "${GREEN}‚úÖ Hist√≥rico salvo em: ${CYAN}$HISTORY_FILE${NC}"
}

# Fun√ß√£o para gerar dashboard HTML-like em markdown
generate_dashboard() {
    echo -e "${BLUE}üìä Gerando dashboard de qualidade...${NC}"
    
    # Calcular tend√™ncia se h√° hist√≥rico
    local trend=""
    local trend_icon=""
    if [[ -f "$HISTORY_FILE" ]] && [[ $(jq 'length' "$HISTORY_FILE") -gt 1 ]]; then
        local previous_score=$(jq -r '.[-2].metrics.qualityScore // 85' "$HISTORY_FILE")
        local current_score=$QUALITY_SCORE
        local diff=$((current_score - previous_score))
        
        if [[ $diff -gt 0 ]]; then
            trend="‚ÜóÔ∏è +$diff%"
            trend_icon="üìà"
        elif [[ $diff -lt 0 ]]; then
            trend="‚ÜòÔ∏è $diff%"
            trend_icon="üìâ"
        else
            trend="‚Üí Est√°vel"
            trend_icon="üìä"
        fi
    else
        trend="üìä Primeira medi√ß√£o"
        trend_icon="üÜï"
    fi
    
    # Determinar status geral
    local status_color=""
    local status_text=""
    local status_icon=""
    
    if [[ $QUALITY_SCORE -ge 95 ]]; then
        status_color="üü¢"
        status_text="EXCELENTE"
        status_icon="üèÜ"
    elif [[ $QUALITY_SCORE -ge 85 ]]; then
        status_color="üü°"
        status_text="BOM"
        status_icon="‚úÖ"
    elif [[ $QUALITY_SCORE -ge 70 ]]; then
        status_color="üü†"
        status_text="REGULAR"
        status_icon="‚ö†Ô∏è"
    else
        status_color="üî¥"
        status_text="PRECISA MELHORAR"
        status_icon="‚ùå"
    fi
    
    cat > "$DASHBOARD_FILE" << EOF
# üìä **Dashboard de Qualidade da Documenta√ß√£o**

**√öltima Atualiza√ß√£o:** $(date '+%d/%m/%Y %H:%M:%S')  
**Vers√£o:** $(cat "$DOCS_DIR/VERSION" 2>/dev/null || echo "1.0.0")  
**Status Geral:** $status_color **$status_text** $status_icon  

---

## üéØ **Score Geral de Qualidade**

<div align="center">

### $status_icon **$QUALITY_SCORE%** $trend_icon

$trend

</div>

---

## üìä **M√©tricas Principais**

<table>
<tr>
<td width="25%" align="center">

### üìÑ **Arquivos**
**$TOTAL_FILES**  
documentos

</td>
<td width="25%" align="center">

### üìù **Linhas**
**$TOTAL_LINES**  
de conte√∫do

</td>
<td width="25%" align="center">

### üíæ **Tamanho**
**$TOTAL_SIZE**  
total

</td>
<td width="25%" align="center">

### üéØ **Cobertura**
**$COVERAGE_SCORE%**  
documentos obrigat√≥rios

</td>
</tr>
</table>

---

## üîç **An√°lise Detalhada**

### ‚úÖ **Pontos Fortes**
$(if [[ $QUALITY_SCORE -ge 95 ]]; then
    echo "- üèÜ **Qualidade excepcional** - Documenta√ß√£o de n√≠vel internacional"
    echo "- üìö **Cobertura completa** - Todos os aspectos documentados"
    echo "- üéØ **Navega√ß√£o otimizada** - Experi√™ncia do usu√°rio excelente"
elif [[ $QUALITY_SCORE -ge 85 ]]; then
    echo "- ‚úÖ **Boa qualidade geral** - Documenta√ß√£o bem estruturada"
    echo "- üìä **Cobertura adequada** - Principais aspectos cobertos"
    echo "- üó∫Ô∏è **Navega√ß√£o funcional** - Usu√°rios conseguem encontrar informa√ß√µes"
else
    echo "- üìù **Base s√≥lida** - Estrutura b√°sica estabelecida"
    echo "- üîß **Potencial identificado** - √Åreas de melhoria mapeadas"
fi)

### üîß **√Åreas de Melhoria**
$(if [[ $BROKEN_LINKS -gt 0 ]]; then
    echo "- üîó **$BROKEN_LINKS links quebrados** precisam ser corrigidos"
fi
if [[ $MISSING_FILES -gt 0 ]]; then
    echo "- üìÑ **$MISSING_FILES arquivos ausentes** devem ser criados"
fi
if [[ $FORMAT_ISSUES -gt 0 ]]; then
    echo "- üìù **$FORMAT_ISSUES problemas de formata√ß√£o** para revisar"
fi
if [[ $COVERAGE_SCORE -lt 90 ]]; then
    echo "- üìä **Cobertura pode ser expandida** para $((90 - COVERAGE_SCORE))% adicional"
fi)

$(if [[ $BROKEN_LINKS -eq 0 && $MISSING_FILES -eq 0 && $FORMAT_ISSUES -eq 0 && $COVERAGE_SCORE -ge 90 ]]; then
    echo "- üéâ **Nenhuma melhoria cr√≠tica identificada!**"
    echo "- üöÄ **Continue mantendo a qualidade atual**"
fi)

---

## üìà **Hist√≥rico de Qualidade**

$(if [[ -f "$HISTORY_FILE" ]] && [[ $(jq 'length' "$HISTORY_FILE") -gt 1 ]]; then
    echo "### üìä **√öltimas 5 Medi√ß√µes**"
    echo ""
    echo "| Data | Score | Tend√™ncia |"
    echo "|------|-------|-----------|"
    
    jq -r '.[-5:] | reverse | .[] | "| \(.date) | \(.metrics.qualityScore)% | \(if .metrics.qualityScore > 90 then "üü¢" elif .metrics.qualityScore > 80 then "üü°" else "üî¥" end) |"' "$HISTORY_FILE" 2>/dev/null || echo "| $(date '+%Y-%m-%d') | $QUALITY_SCORE% | $status_color |"
else
    echo "### üÜï **Primeira Medi√ß√£o**"
    echo ""
    echo "Esta √© a primeira vez que as m√©tricas s√£o coletadas."
    echo "Execute o dashboard novamente em alguns dias para ver tend√™ncias."
fi)

---

## üéØ **Metas e Objetivos**

### üèÜ **Metas de Qualidade**
- **Target Score:** 95%+ (Excel√™ncia)
- **Score Atual:** $QUALITY_SCORE%
- **Dist√¢ncia da meta:** $((95 - QUALITY_SCORE))%

### üìã **Pr√≥ximas A√ß√µes Recomendadas**
$(if [[ $QUALITY_SCORE -ge 95 ]]; then
    echo "1. üéâ **Manter excel√™ncia atual**"
    echo "2. üìä **Monitorar m√©tricas semanalmente**"
    echo "3. üîÑ **Revisar e atualizar conte√∫do regularmente**"
elif [[ $QUALITY_SCORE -ge 85 ]]; then
    echo "1. üîó **Corrigir links quebrados** (se houver)"
    echo "2. üìù **Melhorar formata√ß√£o** dos documentos"
    echo "3. üìä **Expandir cobertura** para 100%"
else
    echo "1. üö® **Prioridade: Corrigir problemas cr√≠ticos**"
    echo "2. üìÑ **Completar documentos ausentes**"
    echo "3. üèóÔ∏è **Reestruturar navega√ß√£o** se necess√°rio"
fi)

---

## üîß **Ferramentas de Manuten√ß√£o**

### üìã **Scripts Dispon√≠veis**
- **\`scripts/docs/validate_docs.sh\`** - Valida√ß√£o completa da documenta√ß√£o
- **\`scripts/docs/auto_version.sh\`** - Versionamento autom√°tico
- **\`scripts/docs/metrics_dashboard.sh\`** - Este dashboard (execute periodicamente)

### ‚è∞ **Cronograma Recomendado**
- **Di√°rio:** Verifica√ß√£o visual r√°pida
- **Semanal:** Execu√ß√£o do dashboard de m√©tricas
- **Mensal:** Valida√ß√£o completa + versionamento
- **Trimestral:** Revis√£o estrutural e melhorias

---

## üìû **Suporte e Recursos**

### üÜò **Em Caso de Problemas**
- üìã **[Guia de Troubleshooting](troubleshooting/)** - Resolu√ß√£o de problemas
- üé® **[Style Guide](templates/style-guide.md)** - Padr√µes de documenta√ß√£o
- üìä **[Status do Projeto](project-management/status.md)** - Progresso atual

### üîó **Links √öteis**
- üè† **[Documenta√ß√£o Principal](README.md)** - In√≠cio
- üë• **[Guia do Usu√°rio](user-guide/getting-started.md)** - Como usar
- üë®‚Äçüíª **[Guia do Desenvolvedor](developer-guide/quick-start.md)** - Como contribuir

---

<div align="center">

### üéØ **Objetivo: Documenta√ß√£o de Classe Mundial**

*Medindo, monitorando e melhorando continuamente*

**Pr√≥xima execu√ß√£o recomendada:** $(date -d '+7 days' '+%d/%m/%Y')

</div>

---

*Dashboard gerado automaticamente em $(date '+%d/%m/%Y %H:%M:%S')*
EOF

    echo -e "${GREEN}‚úÖ Dashboard gerado em: ${CYAN}$DASHBOARD_FILE${NC}"
}

# Fun√ß√£o para mostrar resumo no terminal
show_terminal_summary() {
    echo ""
    echo -e "${BLUE}üìä RESUMO EXECUTIVO${NC}"
    echo "================================================================="
    echo -e "üéØ Score Geral: ${YELLOW}$QUALITY_SCORE%${NC}"
    echo -e "üìÑ Total de Arquivos: ${YELLOW}$TOTAL_FILES${NC}"
    echo -e "üìù Total de Linhas: ${YELLOW}$TOTAL_LINES${NC}"
    echo -e "üíæ Tamanho Total: ${YELLOW}$TOTAL_SIZE${NC}"
    echo -e "üìä Cobertura: ${YELLOW}$COVERAGE_SCORE%${NC}"
    echo ""
    
    if [[ $QUALITY_SCORE -ge 95 ]]; then
        echo -e "${GREEN}üèÜ EXCELENTE! Documenta√ß√£o de alta qualidade${NC}"
    elif [[ $QUALITY_SCORE -ge 85 ]]; then
        echo -e "${YELLOW}‚úÖ BOM! Qualidade aceit√°vel com espa√ßo para melhorias${NC}"
    else
        echo -e "${RED}‚ö†Ô∏è  ATEN√á√ÉO! Documenta√ß√£o precisa de melhorias${NC}"
    fi
    
    echo ""
    echo -e "üìä Dashboard completo: ${CYAN}$DASHBOARD_FILE${NC}"
}

# Fun√ß√£o principal
main() {
    echo -e "${BLUE}üöÄ Iniciando coleta de m√©tricas...${NC}"
    echo ""
    
    # Setup
    setup_directories
    echo ""
    
    # Coletar m√©tricas
    collect_basic_metrics
    echo ""
    
    analyze_coverage
    echo ""
    
    analyze_content_quality
    echo ""
    
    load_validation_metrics
    echo ""
    
    calculate_overall_score
    echo ""
    
    # Salvar e gerar relat√≥rios
    save_metrics_history
    echo ""
    
    generate_dashboard
    echo ""
    
    show_terminal_summary
    
    echo -e "${GREEN}‚úÖ M√©tricas coletadas e dashboard atualizado!${NC}"
}

# Ajuda
show_help() {
    cat << EOF
üìä **Dashboard de M√©tricas da Documenta√ß√£o**

USO:
    $0 [OP√á√ÉO]

OP√á√ïES:
    (sem argumentos)  Executar coleta completa de m√©tricas
    -h, --help       Mostrar esta ajuda

FUNCIONALIDADES:
    üìä Coleta autom√°tica de m√©tricas de qualidade
    üìà Hist√≥rico de evolu√ß√£o da documenta√ß√£o  
    üéØ Score geral de qualidade calculado
    üìã Dashboard visual em markdown
    üîç An√°lise de cobertura e estrutura
    üíæ Persist√™ncia de dados hist√≥ricos

M√âTRICAS COLETADAS:
    üìÑ N√∫mero total de arquivos
    üìù Total de linhas de documenta√ß√£o
    üíæ Tamanho total da documenta√ß√£o
    üéØ Score de cobertura dos documentos obrigat√≥rios
    üîó Links quebrados (requer valida√ß√£o pr√©via)
    üìä Problemas de formata√ß√£o
    üèÜ Score geral de qualidade

ARQUIVOS GERADOS:
    - $DASHBOARD_FILE
    - $HISTORY_FILE
    - $METRICS_JSON (se validate_docs.sh foi executado)

FREQU√äNCIA RECOMENDADA:
    - Semanal: Para acompanhar tend√™ncias
    - Ap√≥s mudan√ßas: Para medir impacto
    - Mensal: Para relat√≥rios de qualidade

EOF
}

# Processamento de argumentos
case "${1:-}" in
    -h|--help)
        show_help
        ;;
    "")
        main
        ;;
    *)
        echo -e "${RED}‚ùå Argumento inv√°lido: $1${NC}"
        echo -e "${YELLOW}   Use -h para ajuda${NC}"
        exit 1
        ;;
esac 